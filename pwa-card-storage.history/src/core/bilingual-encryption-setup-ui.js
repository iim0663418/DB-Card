/**
 * BilingualEncryptionSetupUI - ÈõôË™ûÂä†ÂØÜË®≠ÂÆöËàáËß£Èéñ‰ªãÈù¢
 * ÂØ¶‰Ωú UCE-02 Âíå UCE-03 ‰ªªÂãôÈúÄÊ±Ç
 * 
 * Features:
 * - ‰∏âÁü≠Ë™ûË®≠ÂÆöÂ∞çË©±Ê°Ü (UCE-02)
 * - Ëß£ÈéñÂ∞çË©±Ê°Ü (UCE-03)
 * - ÈõôË™ûÊîØÊè¥ (‰∏≠Êñá/Ëã±Êñá)
 * - moda Ë®≠Ë®àÁ≥ªÁµ±Êï¥Âêà
 * - È´òÈΩ°ÂèãÂñÑË®≠Ë®à
 * - ÁÜµÂÄºÈ©óË≠âËàáÂÆâÂÖ®Âª∫Ë≠∞
 */

class BilingualEncryptionSetupUI {
  constructor() {
    this.currentLanguage = 'zh-TW';
    this.isDialogOpen = false;
    this.retryAttempts = 0;
    this.maxRetryAttempts = 3;
    
    // Ë©ûÂ∫´ÂÆöÁæ©
    this.vocabulary = {
      'zh-TW': {
        adjectives: ['ÁæéÈ∫ó', 'ËÅ∞Êòé', 'Âø´Ê®Ç', 'Ê∫´Êöñ', 'Êòé‰∫Æ', 'ÂÆâÈùú', 'ÂãáÊï¢', 'ÂñÑËâØ', 'Ê¥ªÊΩë', 'ÂÑ™ÈõÖ'],
        nouns: ['Ëä±Êúµ', 'ÊòüÊòü', 'Êµ∑Ê¥ã', 'Â±±Â≥∞', 'Ê£ÆÊûó', 'ÂΩ©Ëôπ', 'ÈôΩÂÖâ', 'Êúà‰∫Æ', 'Èõ≤Êúµ', 'Ê≤≥ÊµÅ'],
        verbs: ['È£õÁøî', 'Ê≠åÂî±', 'Ë∑≥Ëàû', 'ÂæÆÁ¨ë', 'ÈñÉËÄÄ', 'ÊàêÈï∑', 'Êé¢Á¥¢', 'ÂâµÈÄ†', 'ÂàÜ‰∫´', 'Â§¢ÊÉ≥']
      },
      'en-US': {
        adjectives: ['beautiful', 'bright', 'happy', 'gentle', 'strong', 'wise', 'calm', 'brave', 'kind', 'creative'],
        nouns: ['flower', 'star', 'ocean', 'mountain', 'forest', 'rainbow', 'sunshine', 'moon', 'cloud', 'river'],
        verbs: ['dance', 'sing', 'smile', 'shine', 'grow', 'explore', 'create', 'share', 'dream', 'inspire']
      }
    };
    
    // ÁøªË≠ØÂ≠óÂÖ∏
    this.translations = {
      'zh-TW': {
        setupTitle: 'Ë®≠ÂÆöÊÇ®ÁöÑÂä†ÂØÜÂØÜÁ¢ºÁü≠Ë™û',
        unlockTitle: 'Ëß£ÈéñÊÇ®ÁöÑÊï∏‰ΩçÂêçÁâá',
        setupSubtitle: 'Ë´ãÈÅ∏Êìá‰∏âÂÄãË©ûË™ûÁµÑÊàêÊÇ®ÁöÑÂ∞àÂ±¨ÂØÜÁ¢ºÁü≠Ë™û',
        unlockSubtitle: 'Ë´ãËº∏ÂÖ•ÊÇ®ÁöÑ‰∏âÁü≠Ë™ûÂØÜÁ¢º‰ª•Ëß£Èéñ',
        adjective: 'ÂΩ¢ÂÆπË©û',
        noun: 'ÂêçË©û',
        verb: 'ÂãïË©û',
        generate: 'ÈáçÊñ∞ÁîüÊàê',
        confirm: 'Á¢∫Ë™çË®≠ÂÆö',
        unlock: 'Ëß£Èéñ',
        cancel: 'ÂèñÊ∂à',
        entropyWeak: 'ÂÆâÂÖ®ÊÄßËºÉ‰ΩéÔºåÂª∫Ë≠∞ÈÅ∏ÊìáÊõ¥Ë§áÈõúÁöÑË©ûË™û',
        entropyGood: 'ÂÆâÂÖ®ÊÄßËâØÂ•Ω',
        entropyStrong: 'ÂÆâÂÖ®ÊÄßÊ•µ‰Ω≥',
        unlockFailed: 'ÂØÜÁ¢ºÁü≠Ë™ûÈåØË™§ÔºåË´ãÈáçË©¶',
        attemptsRemaining: 'Ââ©È§òÂòóË©¶Ê¨°Êï∏',
        recoveryMode: 'ÈÄ≤ÂÖ•ÊÅ¢Âæ©Ê®°Âºè',
        preview: 'È†êË¶Ω',
        securityTip: 'ÊèêÁ§∫ÔºöË´ãË®ò‰ΩèÈÄô‰∏âÂÄãË©ûË™ûÔºåÂÆÉÂÄëÊòØÊÇ®ÂîØ‰∏ÄÁöÑËß£ÈéñÊñπÂºè'
      },
      'en-US': {
        setupTitle: 'Set Your Encryption Passphrase',
        unlockTitle: 'Unlock Your Digital Cards',
        setupSubtitle: 'Please choose three words to create your unique passphrase',
        unlockSubtitle: 'Please enter your three-word passphrase to unlock',
        adjective: 'Adjective',
        noun: 'Noun',
        verb: 'Verb',
        generate: 'Regenerate',
        confirm: 'Confirm Setup',
        unlock: 'Unlock',
        cancel: 'Cancel',
        entropyWeak: 'Low security, consider choosing more complex words',
        entropyGood: 'Good security',
        entropyStrong: 'Excellent security',
        unlockFailed: 'Incorrect passphrase, please try again',
        attemptsRemaining: 'Attempts remaining',
        recoveryMode: 'Enter Recovery Mode',
        preview: 'Preview',
        securityTip: 'Tip: Remember these three words - they are your only way to unlock'
      }
    };
  }

  /**
   * È°ØÁ§∫‰∏âÁü≠Ë™ûË®≠ÂÆöÂ∞çË©±Ê°Ü (UCE-02)
   */
  async showSetupDialog(language = 'zh-TW') {
    this.currentLanguage = language;
    
    return new Promise((resolve) => {
      if (this.isDialogOpen) {
        resolve({ cancelled: true });
        return;
      }
      
      this.isDialogOpen = true;
      const dialog = this.createSetupDialog(resolve);
      document.body.appendChild(dialog);
      
      // ÂàùÂßãÁîüÊàêÂª∫Ë≠∞Ë©ûË™û
      this.generateSuggestions();
      
      // ÁÑ¶ÈªûÁÆ°ÁêÜ
      setTimeout(() => {
        const firstInput = dialog.querySelector('input');
        if (firstInput) firstInput.focus();
      }, 100);
    });
  }

  /**
   * È°ØÁ§∫Ëß£ÈéñÂ∞çË©±Ê°Ü (UCE-03)
   */
  async showUnlockDialog(language = 'zh-TW') {
    this.currentLanguage = language;
    this.retryAttempts = 0;
    
    return new Promise((resolve) => {
      if (this.isDialogOpen) {
        resolve({ cancelled: true });
        return;
      }
      
      this.isDialogOpen = true;
      const dialog = this.createUnlockDialog(resolve);
      document.body.appendChild(dialog);
      
      // ÁÑ¶ÈªûÁÆ°ÁêÜ
      setTimeout(() => {
        const firstInput = dialog.querySelector('input');
        if (firstInput) firstInput.focus();
      }, 100);
    });
  }

  /**
   * ÂâµÂª∫Ë®≠ÂÆöÂ∞çË©±Ê°Ü
   */
  createSetupDialog(resolve) {
    const t = this.translations[this.currentLanguage];
    
    const dialog = document.createElement('div');
    dialog.className = 'encryption-dialog-overlay';
    dialog.innerHTML = `
      <div class="encryption-dialog setup-dialog" role="dialog" aria-labelledby="setup-title">
        <div class="dialog-header">
          <h2 id="setup-title" class="dialog-title">${t.setupTitle}</h2>
          <p class="dialog-subtitle">${t.setupSubtitle}</p>
        </div>
        
        <div class="dialog-content">
          <div class="phrase-inputs">
            <div class="input-group">
              <label for="adjective-input" class="input-label">${t.adjective}</label>
              <div class="input-with-suggestion">
                <input 
                  type="text" 
                  id="adjective-input" 
                  class="phrase-input" 
                  placeholder="${t.adjective}"
                  aria-describedby="adjective-suggestion"
                  autocomplete="off"
                />
                <button type="button" class="suggestion-btn" data-type="adjective" aria-label="‰ΩøÁî®Âª∫Ë≠∞Ë©ûË™û">
                  <span id="adjective-suggestion" class="suggestion-text"></span>
                </button>
              </div>
            </div>
            
            <div class="input-group">
              <label for="noun-input" class="input-label">${t.noun}</label>
              <div class="input-with-suggestion">
                <input 
                  type="text" 
                  id="noun-input" 
                  class="phrase-input" 
                  placeholder="${t.noun}"
                  aria-describedby="noun-suggestion"
                  autocomplete="off"
                />
                <button type="button" class="suggestion-btn" data-type="noun" aria-label="‰ΩøÁî®Âª∫Ë≠∞Ë©ûË™û">
                  <span id="noun-suggestion" class="suggestion-text"></span>
                </button>
              </div>
            </div>
            
            <div class="input-group">
              <label for="verb-input" class="input-label">${t.verb}</label>
              <div class="input-with-suggestion">
                <input 
                  type="text" 
                  id="verb-input" 
                  class="phrase-input" 
                  placeholder="${t.verb}"
                  aria-describedby="verb-suggestion"
                  autocomplete="off"
                />
                <button type="button" class="suggestion-btn" data-type="verb" aria-label="‰ΩøÁî®Âª∫Ë≠∞Ë©ûË™û">
                  <span id="verb-suggestion" class="suggestion-text"></span>
                </button>
              </div>
            </div>
          </div>
          
          <div class="phrase-preview">
            <label class="preview-label">${t.preview}:</label>
            <div class="preview-text" id="phrase-preview" aria-live="polite"></div>
          </div>
          
          <div class="entropy-indicator">
            <div class="entropy-bar">
              <div class="entropy-fill" id="entropy-fill"></div>
            </div>
            <div class="entropy-text" id="entropy-text" aria-live="polite"></div>
          </div>
          
          <div class="security-tip">
            <i class="tip-icon">üí°</i>
            <span class="tip-text">${t.securityTip}</span>
          </div>
        </div>
        
        <div class="dialog-actions">
          <button type="button" class="btn btn-secondary" id="generate-btn">
            ${t.generate}
          </button>
          <button type="button" class="btn btn-secondary" id="cancel-btn">
            ${t.cancel}
          </button>
          <button type="button" class="btn btn-primary" id="confirm-btn" disabled>
            ${t.confirm}
          </button>
        </div>
      </div>
    `;
    
    this.attachSetupEventListeners(dialog, resolve);
    return dialog;
  }

  /**
   * ÂâµÂª∫Ëß£ÈéñÂ∞çË©±Ê°Ü
   */
  createUnlockDialog(resolve) {
    const t = this.translations[this.currentLanguage];
    
    const dialog = document.createElement('div');
    dialog.className = 'encryption-dialog-overlay';
    dialog.innerHTML = `
      <div class="encryption-dialog unlock-dialog" role="dialog" aria-labelledby="unlock-title">
        <div class="dialog-header">
          <h2 id="unlock-title" class="dialog-title">${t.unlockTitle}</h2>
          <p class="dialog-subtitle">${t.unlockSubtitle}</p>
        </div>
        
        <div class="dialog-content">
          <div class="phrase-inputs">
            <div class="input-group">
              <label for="unlock-adjective" class="input-label">${t.adjective}</label>
              <input 
                type="text" 
                id="unlock-adjective" 
                class="phrase-input" 
                placeholder="${t.adjective}"
                autocomplete="off"
              />
            </div>
            
            <div class="input-group">
              <label for="unlock-noun" class="input-label">${t.noun}</label>
              <input 
                type="text" 
                id="unlock-noun" 
                class="phrase-input" 
                placeholder="${t.noun}"
                autocomplete="off"
              />
            </div>
            
            <div class="input-group">
              <label for="unlock-verb" class="input-label">${t.verb}</label>
              <input 
                type="text" 
                id="unlock-verb" 
                class="phrase-input" 
                placeholder="${t.verb}"
                autocomplete="off"
              />
            </div>
          </div>
          
          <div class="unlock-status" id="unlock-status" aria-live="polite"></div>
          
          <div class="retry-info" id="retry-info" style="display: none;">
            <span class="retry-text">${t.attemptsRemaining}: <span id="attempts-count">${this.maxRetryAttempts}</span></span>
          </div>
        </div>
        
        <div class="dialog-actions">
          <button type="button" class="btn btn-secondary" id="unlock-cancel-btn">
            ${t.cancel}
          </button>
          <button type="button" class="btn btn-danger" id="recovery-btn" style="display: none;">
            ${t.recoveryMode}
          </button>
          <button type="button" class="btn btn-primary" id="unlock-confirm-btn">
            ${t.unlock}
          </button>
        </div>
      </div>
    `;
    
    this.attachUnlockEventListeners(dialog, resolve);
    return dialog;
  }

  /**
   * ÈôÑÂä†Ë®≠ÂÆöÂ∞çË©±Ê°Ü‰∫ã‰ª∂Áõ£ËÅΩÂô®
   */
  attachSetupEventListeners(dialog, resolve) {
    const inputs = dialog.querySelectorAll('.phrase-input');
    const generateBtn = dialog.getElementById('generate-btn');
    const cancelBtn = dialog.getElementById('cancel-btn');
    const confirmBtn = dialog.getElementById('confirm-btn');
    const suggestionBtns = dialog.querySelectorAll('.suggestion-btn');
    
    // Ëº∏ÂÖ•ËÆäÂåñÁõ£ËÅΩ
    inputs.forEach(input => {
      input.addEventListener('input', () => {
        this.updatePreview(dialog);
        this.validateEntropy(dialog);
      });
      
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          const nextInput = this.getNextInput(input, inputs);
          if (nextInput) {
            nextInput.focus();
          } else if (!confirmBtn.disabled) {
            confirmBtn.click();
          }
        }
      });
    });
    
    // Âª∫Ë≠∞Ë©ûË™ûÊåâÈàï
    suggestionBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        const type = btn.dataset.type;
        const input = dialog.getElementById(`${type}-input`);
        const suggestion = btn.querySelector('.suggestion-text').textContent;
        input.value = suggestion;
        this.updatePreview(dialog);
        this.validateEntropy(dialog);
      });
    });
    
    // ÈáçÊñ∞ÁîüÊàêÊåâÈàï
    generateBtn.addEventListener('click', () => {
      this.generateSuggestions();
    });
    
    // ÂèñÊ∂àÊåâÈàï
    cancelBtn.addEventListener('click', () => {
      this.closeDialog(dialog);
      resolve({ cancelled: true });
    });
    
    // Á¢∫Ë™çÊåâÈàï
    confirmBtn.addEventListener('click', () => {
      const phrases = this.collectPhrases(dialog);
      this.closeDialog(dialog);
      resolve({ phrases, cancelled: false });
    });
    
    // ESC ÈçµÈóúÈñâ
    dialog.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        cancelBtn.click();
      }
    });
  }

  /**
   * ÈôÑÂä†Ëß£ÈéñÂ∞çË©±Ê°Ü‰∫ã‰ª∂Áõ£ËÅΩÂô®
   */
  attachUnlockEventListeners(dialog, resolve) {
    const inputs = dialog.querySelectorAll('.phrase-input');
    const cancelBtn = dialog.getElementById('unlock-cancel-btn');
    const confirmBtn = dialog.getElementById('unlock-confirm-btn');
    const recoveryBtn = dialog.getElementById('recovery-btn');
    
    // Ëº∏ÂÖ•‰∫ã‰ª∂
    inputs.forEach(input => {
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          const nextInput = this.getNextInput(input, inputs);
          if (nextInput) {
            nextInput.focus();
          } else {
            confirmBtn.click();
          }
        }
      });
    });
    
    // ÂèñÊ∂àÊåâÈàï
    cancelBtn.addEventListener('click', () => {
      this.closeDialog(dialog);
      resolve({ cancelled: true });
    });
    
    // Ëß£ÈéñÊåâÈàï
    confirmBtn.addEventListener('click', async () => {
      const phrases = this.collectPhrases(dialog, 'unlock-');
      const isValid = await this.validateUnlockPhrases(phrases);
      
      if (isValid) {
        this.closeDialog(dialog);
        resolve({ phrases, cancelled: false });
      } else {
        this.handleUnlockFailure(dialog);
      }
    });
    
    // ÊÅ¢Âæ©Ê®°ÂºèÊåâÈàï
    recoveryBtn.addEventListener('click', () => {
      this.closeDialog(dialog);
      resolve({ cancelled: true, recoveryMode: true });
    });
    
    // ESC ÈçµÈóúÈñâ
    dialog.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        cancelBtn.click();
      }
    });
  }

  /**
   * ÁîüÊàêÂª∫Ë≠∞Ë©ûË™û
   */
  generateSuggestions() {
    const vocab = this.vocabulary[this.currentLanguage];
    
    ['adjective', 'noun', 'verb'].forEach(type => {
      const words = vocab[type + 's'];
      const randomWord = words[Math.floor(Math.random() * words.length)];
      const suggestionElement = document.getElementById(`${type}-suggestion`);
      if (suggestionElement) {
        suggestionElement.textContent = randomWord;
      }
    });
  }

  /**
   * Êõ¥Êñ∞È†êË¶Ω
   */
  updatePreview(dialog) {
    const phrases = this.collectPhrases(dialog);
    const preview = dialog.getElementById('phrase-preview');
    if (preview && phrases.adjective && phrases.noun && phrases.verb) {
      preview.textContent = `${phrases.adjective} ${phrases.noun} ${phrases.verb}`;
    } else {
      preview.textContent = '';
    }
  }

  /**
   * È©óË≠âÁÜµÂÄº
   */
  validateEntropy(dialog) {
    const phrases = this.collectPhrases(dialog);
    const entropy = this.calculateEntropy(phrases);
    const t = this.translations[this.currentLanguage];
    
    const entropyFill = dialog.getElementById('entropy-fill');
    const entropyText = dialog.getElementById('entropy-text');
    const confirmBtn = dialog.getElementById('confirm-btn');
    
    let level, message, percentage;
    
    if (entropy < 40) {
      level = 'weak';
      message = t.entropyWeak;
      percentage = Math.min(entropy / 40 * 100, 100);
    } else if (entropy < 60) {
      level = 'good';
      message = t.entropyGood;
      percentage = Math.min((entropy - 40) / 20 * 100 + 50, 100);
    } else {
      level = 'strong';
      message = t.entropyStrong;
      percentage = 100;
    }
    
    entropyFill.style.width = `${percentage}%`;
    entropyFill.className = `entropy-fill entropy-${level}`;
    entropyText.textContent = message;
    
    // ÂïüÁî®/Á¶ÅÁî®Á¢∫Ë™çÊåâÈàï
    const hasAllPhrases = phrases.adjective && phrases.noun && phrases.verb;
    confirmBtn.disabled = !hasAllPhrases || entropy < 30;
  }

  /**
   * Ë®àÁÆóÁÜµÂÄº
   */
  calculateEntropy(phrases) {
    if (!phrases.adjective || !phrases.noun || !phrases.verb) {
      return 0;
    }
    
    const vocab = this.vocabulary[this.currentLanguage];
    const baseEntropy = Math.log2(vocab.adjectives.length * vocab.nouns.length * vocab.verbs.length);
    
    // Èï∑Â∫¶ÁçéÂãµ
    const lengthBonus = (phrases.adjective.length + phrases.noun.length + phrases.verb.length) * 0.5;
    
    // Ë™ûË®ÄÁâπÂÆöË™øÊï¥
    const langMultiplier = this.currentLanguage === 'zh-TW' ? 1.2 : 1.0;
    
    return Math.min((baseEntropy + lengthBonus) * langMultiplier, 100);
  }

  /**
   * Êî∂ÈõÜÁü≠Ë™û
   */
  collectPhrases(dialog, prefix = '') {
    return {
      adjective: dialog.getElementById(`${prefix}adjective${prefix ? '' : '-input'}`).value.trim(),
      noun: dialog.getElementById(`${prefix}noun${prefix ? '' : '-input'}`).value.trim(),
      verb: dialog.getElementById(`${prefix}verb${prefix ? '' : '-input'}`).value.trim(),
      language: this.currentLanguage
    };
  }

  /**
   * UCE-FIX-03: È©óË≠âËß£ÈéñÁü≠Ë™û - Êï¥ÂêàÁúüÂØ¶ UserKeyManager
   */
  async validateUnlockPhrases(phrases) {
    try {
      // Ê™¢Êü• UserKeyManager ÊòØÂê¶ÂèØÁî®
      if (typeof window === 'undefined' || !window.UserKeyManager) {
        console.error('[BilingualEncryptionSetupUI] UserKeyManager not available');
        return false;
      }

      // Áç≤ÂèñÂÖ®Âüü storage ÂØ¶‰æã
      const storage = window.pwaStorage || window.storage;
      if (!storage) {
        console.error('[BilingualEncryptionSetupUI] Storage not available');
        return false;
      }

      // ÂâµÂª∫ÊàñÁç≤Âèñ UserKeyManager ÂØ¶‰æã
      let userKeyManager;
      if (storage.userKeyManager) {
        userKeyManager = storage.userKeyManager;
      } else {
        userKeyManager = new window.UserKeyManager(storage);
      }

      // ËΩâÊèõÁü≠Ë™ûÊ†ºÂºèÁÇ∫ UserKeyManager ÊúüÊúõÁöÑÊ†ºÂºè
      const phraseData = {
        phrase1: phrases.adjective,
        phrase2: phrases.noun,
        phrase3: phrases.verb
      };

      // Ë™øÁî®ÂØ¶ÈöõÈ©óË≠âÊñπÊ≥ï
      const result = await userKeyManager.verifyUserPassphrase(phraseData);
      
      return result.success;

    } catch (error) {
      console.error('[BilingualEncryptionSetupUI] Validation error:', error);
      return false;
    }
  }

  /**
   * ËôïÁêÜËß£ÈéñÂ§±Êïó
   */
  handleUnlockFailure(dialog) {
    const t = this.translations[this.currentLanguage];
    this.retryAttempts++;
    
    const statusElement = dialog.getElementById('unlock-status');
    const retryInfo = dialog.getElementById('retry-info');
    const attemptsCount = dialog.getElementById('attempts-count');
    const recoveryBtn = dialog.getElementById('recovery-btn');
    
    statusElement.textContent = t.unlockFailed;
    statusElement.className = 'unlock-status error';
    
    const remaining = this.maxRetryAttempts - this.retryAttempts;
    attemptsCount.textContent = remaining;
    retryInfo.style.display = 'block';
    
    if (remaining <= 0) {
      recoveryBtn.style.display = 'inline-block';
      dialog.getElementById('unlock-confirm-btn').disabled = true;
    }
    
    // Ê∏ÖÁ©∫Ëº∏ÂÖ•Ê°Ü‰∏¶ËÅöÁÑ¶Á¨¨‰∏ÄÂÄã
    const inputs = dialog.querySelectorAll('.phrase-input');
    inputs.forEach(input => input.value = '');
    if (inputs.length > 0) inputs[0].focus();
  }

  /**
   * Áç≤Âèñ‰∏ã‰∏ÄÂÄãËº∏ÂÖ•Ê°Ü
   */
  getNextInput(currentInput, inputs) {
    const currentIndex = Array.from(inputs).indexOf(currentInput);
    return inputs[currentIndex + 1] || null;
  }

  /**
   * ÈóúÈñâÂ∞çË©±Ê°Ü
   */
  closeDialog(dialog) {
    this.isDialogOpen = false;
    dialog.remove();
  }

  /**
   * UCE-FIX-03: Ë®≠ÂÆö‰ΩøÁî®ËÄÖÂØÜÁ¢ºÁü≠Ë™û - Êï¥Âêà UserKeyManager
   */
  async setupUserPassphrase(phrases) {
    try {
      // Ê™¢Êü• UserKeyManager ÊòØÂê¶ÂèØÁî®
      if (typeof window === 'undefined' || !window.UserKeyManager) {
        throw new Error('UserKeyManager not available');
      }

      // Áç≤ÂèñÂÖ®Âüü storage ÂØ¶‰æã
      const storage = window.pwaStorage || window.storage;
      if (!storage) {
        throw new Error('Storage not available');
      }

      // ÂâµÂª∫ÊàñÁç≤Âèñ UserKeyManager ÂØ¶‰æã
      let userKeyManager;
      if (storage.userKeyManager) {
        userKeyManager = storage.userKeyManager;
      } else {
        userKeyManager = new window.UserKeyManager(storage);
        storage.userKeyManager = userKeyManager;
      }

      // ËΩâÊèõÁü≠Ë™ûÊ†ºÂºè
      const phraseData = {
        phrase1: phrases.adjective,
        phrase2: phrases.noun,
        phrase3: phrases.verb
      };

      // Ë®≠ÂÆö‰ΩøÁî®ËÄÖÂØÜÁ¢ºÁü≠Ë™û
      const result = await userKeyManager.setUserPassphrase(phraseData);
      
      return result;

    } catch (error) {
      console.error('[BilingualEncryptionSetupUI] Setup error:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Ë™ûË®ÄÂàáÊèõ
   */
  async switchLanguage(language) {
    this.currentLanguage = language;
    // Â¶ÇÊûúÊúâÊâìÈñãÁöÑÂ∞çË©±Ê°ÜÔºåÈáçÊñ∞Ê∏≤Êüì
    const openDialog = document.querySelector('.encryption-dialog-overlay');
    if (openDialog) {
      // ÈáçÊñ∞Ê∏≤ÊüìÈÇèËºØÂèØ‰ª•Âú®ÈÄôË£°ÂØ¶‰Ωú
      console.log(`Language switched to ${language}`);
    }
  }
}

// Â∞éÂá∫È°ûÂà•
if (typeof module !== 'undefined' && module.exports) {
  module.exports = BilingualEncryptionSetupUI;
} else if (typeof window !== 'undefined') {
  window.BilingualEncryptionSetupUI = BilingualEncryptionSetupUI;
}

// ÁÇ∫ Node.js Áí∞Â¢ÉÊèê‰æõÂÖ®ÂüüË®™Âïè
if (typeof global !== 'undefined') {
  global.BilingualEncryptionSetupUI = BilingualEncryptionSetupUI;
}