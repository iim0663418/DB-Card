/**
 * PWA-17: Client-Side Vulnerability Scanning
 * Automated security checks for PWA configuration and dependencies
 */
class ClientVulnerabilityScanner {
    static #scanResults = new Map();
    static #config = {
        scanInterval: 60 * 60 * 1000, // 1 hour
        criticalThreshold: 1,
        highThreshold: 3
    };

    /**
     * Perform comprehensive security scan
     */
    static async performSecurityScan() {
        const scanId = 'scan_' + Date.now();
        const results = {
            scanId,
            timestamp: Date.now(),
            vulnerabilities: [],
            recommendations: [],
            score: 100
        };

        try {
            // PWA Configuration Security
            const pwaVulns = await this.#scanPWAConfiguration();
            results.vulnerabilities.push(...pwaVulns);

            // Client-Side Dependencies
            const depVulns = await this.#scanDependencies();
            results.vulnerabilities.push(...depVulns);

            // Security Headers
            const headerVulns = await this.#scanSecurityHeaders();
            results.vulnerabilities.push(...headerVulns);

            // Content Security Policy
            const cspVulns = await this.#scanCSP();
            results.vulnerabilities.push(...cspVulns);

            // Local Storage Security
            const storageVulns = await this.#scanStorageSecurity();
            results.vulnerabilities.push(...storageVulns);

            // Calculate security score
            results.score = this.#calculateSecurityScore(results.vulnerabilities);
            
            // Generate recommendations
            results.recommendations = this.#generateRecommendations(results.vulnerabilities);

            this.#scanResults.set(scanId, results);
            
            // Log scan completion
            if (window.OfflineSecurityLogger) {
                await window.OfflineSecurityLogger.logSecurityEvent('info', 'Security scan completed', {
                    scanId,
                    vulnerabilityCount: results.vulnerabilities.length,
                    score: results.score
                });
            }

            return results;
        } catch (error) {
            results.error = error.message;
            results.score = 0;
            return results;
        }
    }

    /**
     * Get latest scan results
     */
    static getLatestScanResults() {
        const scans = Array.from(this.#scanResults.values());
        return scans.sort((a, b) => b.timestamp - a.timestamp)[0] || null;
    }

    /**
     * Get vulnerability summary
     */
    static getVulnerabilitySummary() {
        const latest = this.getLatestScanResults();
        if (!latest) return null;

        const summary = {
            total: latest.vulnerabilities.length,
            critical: 0,
            high: 0,
            medium: 0,
            low: 0,
            score: latest.score
        };

        latest.vulnerabilities.forEach(vuln => {
            summary[vuln.severity]++;
        });

        return summary;
    }

    // Private scanning methods
    static async #scanPWAConfiguration() {
        const vulnerabilities = [];

        try {
            // Check manifest.json
            const manifestResponse = await fetch('/pwa-card-storage/manifest.json');
            if (manifestResponse.ok) {
                const manifest = await manifestResponse.json();
                
                // Check for insecure start_url
                if (manifest.start_url && !manifest.start_url.startsWith('https://')) {
                    vulnerabilities.push({
                        id: 'PWA-001',
                        title: 'Insecure PWA start_url',
                        severity: 'medium',
                        description: 'PWA manifest uses non-HTTPS start_url',
                        recommendation: 'Use HTTPS for start_url in manifest.json'
                    });
                }

                // Check for missing security-related fields
                if (!manifest.display || manifest.display === 'browser') {
                    vulnerabilities.push({
                        id: 'PWA-002',
                        title: 'PWA display mode not optimized',
                        severity: 'low',
                        description: 'PWA should use standalone or fullscreen display mode',
                        recommendation: 'Set display to "standalone" in manifest.json'
                    });
                }
            }

            // Check Service Worker registration
            if (!('serviceWorker' in navigator)) {
                vulnerabilities.push({
                    id: 'PWA-003',
                    title: 'Service Worker not supported',
                    severity: 'high',
                    description: 'Browser does not support Service Workers',
                    recommendation: 'Ensure PWA runs on modern browsers with SW support'
                });
            }

        } catch (error) {
            vulnerabilities.push({
                id: 'PWA-004',
                title: 'PWA configuration scan failed',
                severity: 'medium',
                description: 'Unable to verify PWA configuration',
                recommendation: 'Ensure manifest.json is accessible and valid'
            });
        }

        return vulnerabilities;
    }

    static async #scanDependencies() {
        const vulnerabilities = [];

        // Check for known vulnerable patterns in loaded scripts
        const scripts = Array.from(document.scripts);
        
        scripts.forEach((script, index) => {
            // Check for inline scripts (potential XSS risk)
            if (script.innerHTML.trim() && !script.src) {
                vulnerabilities.push({
                    id: `DEP-001-${index}`,
                    title: 'Inline script detected',
                    severity: 'medium',
                    description: 'Inline scripts can pose XSS risks',
                    recommendation: 'Move inline scripts to external files with CSP nonce'
                });
            }

            // Check for external scripts from non-HTTPS sources
            if (script.src && !script.src.startsWith('https://') && !script.src.startsWith('/')) {
                vulnerabilities.push({
                    id: `DEP-002-${index}`,
                    title: 'Insecure script source',
                    severity: 'high',
                    description: `Script loaded from non-HTTPS source: ${script.src}`,
                    recommendation: 'Use HTTPS for all external script sources'
                });
            }
        });

        // Check for eval() usage (basic static analysis)
        const pageContent = document.documentElement.outerHTML;
        if (pageContent.includes('eval(') || pageContent.includes('Function(')) {
            vulnerabilities.push({
                id: 'DEP-003',
                title: 'Dynamic code execution detected',
                severity: 'high',
                description: 'Use of eval() or Function() constructor detected',
                recommendation: 'Avoid dynamic code execution, use safer alternatives'
            });
        }

        return vulnerabilities;
    }

    static async #scanSecurityHeaders() {
        const vulnerabilities = [];

        try {
            // Check current page headers via fetch
            const response = await fetch(window.location.href, { method: 'HEAD' });
            
            const requiredHeaders = {
                'x-content-type-options': 'nosniff',
                'x-frame-options': ['DENY', 'SAMEORIGIN'],
                'x-xss-protection': '1; mode=block',
                'strict-transport-security': null // Should exist for HTTPS
            };

            for (const [header, expectedValue] of Object.entries(requiredHeaders)) {
                const headerValue = response.headers.get(header);
                
                if (!headerValue) {
                    vulnerabilities.push({
                        id: `HDR-001-${header}`,
                        title: `Missing security header: ${header}`,
                        severity: 'medium',
                        description: `Security header ${header} is not set`,
                        recommendation: `Add ${header} header to server configuration`
                    });
                } else if (expectedValue && Array.isArray(expectedValue)) {
                    if (!expectedValue.some(val => headerValue.includes(val))) {
                        vulnerabilities.push({
                            id: `HDR-002-${header}`,
                            title: `Weak security header: ${header}`,
                            severity: 'low',
                            description: `Header ${header} has weak value: ${headerValue}`,
                            recommendation: `Use stronger value for ${header}`
                        });
                    }
                }
            }

        } catch (error) {
            vulnerabilities.push({
                id: 'HDR-003',
                title: 'Security headers scan failed',
                severity: 'low',
                description: 'Unable to verify security headers',
                recommendation: 'Manually verify security headers are properly configured'
            });
        }

        return vulnerabilities;
    }

    static async #scanCSP() {
        const vulnerabilities = [];

        // Check for CSP meta tag or header
        const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
        let cspValue = cspMeta ? cspMeta.getAttribute('content') : null;

        if (!cspValue) {
            // Try to get from response headers
            try {
                const response = await fetch(window.location.href, { method: 'HEAD' });
                cspValue = response.headers.get('content-security-policy');
            } catch (error) {
                // Ignore fetch errors
            }
        }

        if (!cspValue) {
            vulnerabilities.push({
                id: 'CSP-001',
                title: 'Missing Content Security Policy',
                severity: 'high',
                description: 'No CSP header or meta tag found',
                recommendation: 'Implement strict Content Security Policy'
            });
        } else {
            // Check for unsafe CSP directives
            const unsafePatterns = [
                { pattern: "'unsafe-inline'", severity: 'medium', directive: 'script-src or style-src' },
                { pattern: "'unsafe-eval'", severity: 'high', directive: 'script-src' },
                { pattern: 'data:', severity: 'medium', directive: 'script-src' },
                { pattern: '*', severity: 'high', directive: 'any directive' }
            ];

            unsafePatterns.forEach((check, index) => {
                if (cspValue.includes(check.pattern)) {
                    vulnerabilities.push({
                        id: `CSP-002-${index}`,
                        title: `Unsafe CSP directive: ${check.pattern}`,
                        severity: check.severity,
                        description: `CSP contains unsafe ${check.pattern} in ${check.directive}`,
                        recommendation: `Remove ${check.pattern} and use nonce or hash-based CSP`
                    });
                }
            });
        }

        return vulnerabilities;
    }

    static async #scanStorageSecurity() {
        const vulnerabilities = [];

        // Check localStorage usage
        try {
            const localStorageKeys = Object.keys(localStorage);
            localStorageKeys.forEach(key => {
                const value = localStorage.getItem(key);
                
                // Check for potential sensitive data in localStorage
                if (this.#containsSensitiveData(key, value)) {
                    vulnerabilities.push({
                        id: `STG-001-${key}`,
                        title: 'Sensitive data in localStorage',
                        severity: 'medium',
                        description: `Potentially sensitive data stored in localStorage: ${key}`,
                        recommendation: 'Use encrypted storage for sensitive data'
                    });
                }
            });

            // Check sessionStorage
            const sessionStorageKeys = Object.keys(sessionStorage);
            sessionStorageKeys.forEach(key => {
                const value = sessionStorage.getItem(key);
                
                if (this.#containsSensitiveData(key, value)) {
                    vulnerabilities.push({
                        id: `STG-002-${key}`,
                        title: 'Sensitive data in sessionStorage',
                        severity: 'low',
                        description: `Potentially sensitive data in sessionStorage: ${key}`,
                        recommendation: 'Avoid storing sensitive data in sessionStorage'
                    });
                }
            });

        } catch (error) {
            vulnerabilities.push({
                id: 'STG-003',
                title: 'Storage security scan failed',
                severity: 'low',
                description: 'Unable to scan browser storage',
                recommendation: 'Manually review stored data for sensitive information'
            });
        }

        return vulnerabilities;
    }

    static #containsSensitiveData(key, value) {
        const sensitivePatterns = [
            /password/i, /token/i, /secret/i, /key/i,
            /email/i, /phone/i, /address/i, /ssn/i,
            /credit/i, /card/i, /account/i
        ];

        const keyLower = key.toLowerCase();
        const valueLower = (value || '').toLowerCase();

        return sensitivePatterns.some(pattern => 
            pattern.test(keyLower) || pattern.test(valueLower)
        );
    }

    static #calculateSecurityScore(vulnerabilities) {
        let score = 100;
        
        vulnerabilities.forEach(vuln => {
            switch (vuln.severity) {
                case 'critical': score -= 25; break;
                case 'high': score -= 15; break;
                case 'medium': score -= 8; break;
                case 'low': score -= 3; break;
            }
        });

        return Math.max(0, score);
    }

    static #generateRecommendations(vulnerabilities) {
        const recommendations = [];
        const severityCounts = { critical: 0, high: 0, medium: 0, low: 0 };

        vulnerabilities.forEach(vuln => {
            severityCounts[vuln.severity]++;
        });

        if (severityCounts.critical > 0) {
            recommendations.push('Address critical vulnerabilities immediately');
        }
        if (severityCounts.high > 2) {
            recommendations.push('High-severity issues require urgent attention');
        }
        if (severityCounts.medium > 5) {
            recommendations.push('Consider addressing medium-severity issues in next release');
        }

        return recommendations;
    }

    /**
     * Start automated scanning
     */
    static startAutomatedScanning() {
        // Initial scan
        this.performSecurityScan();

        // Schedule periodic scans
        setInterval(() => {
            this.performSecurityScan();
        }, this.#config.scanInterval);
    }
}

window.ClientVulnerabilityScanner = ClientVulnerabilityScanner;